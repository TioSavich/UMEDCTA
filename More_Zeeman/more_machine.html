<!DOCTYPE html>
<html>
<head>
<title>Friction and Abstraction: The Catastrophe Machine and the More Machine</title>
<style>
    body {
        font-family: "Cantarell", "Verdana", sans-serif;
        background-color: #f4f4f9;
        color: #333;
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        user-select: none;
        -webkit-user-select: none;
    }
    #mainContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        max-width: 800px;
        width: 100%;
    }
    .visualization-box {
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        width: 100%;
    }
    .controls-box {
        background: #fdfdfd;
        border: 2px dashed #ccc;
        border-radius: 8px;
        padding: 15px;
        margin-top: 10px;
        display: flex;
        gap: 25px;
        justify-content: center;
        align-items: center;
    }
    .controls-box label {
        font-size: 1em;
    }
    #zcmContainer {
        text-align: center;
    }
    svg {
        box-shadow: 0px 0px 10px rgba(0,0,0,0.05);
        border: 1px solid #eee;
    }
    #zcmSvg {
        cursor: crosshair;
    }
    .label {
        font-size: 16px;
        font-weight: bold;
        color: #444;
        margin-bottom: 10px;
    }
    #instructions {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        max-width: 800px;
        text-align: center;
        font-size: 14px;
        line-height: 1.5;
        color: #666;
    }
    .band {
        stroke-width: 3;
        transition: stroke 0.1s;
    }
</style>
</head>
<body>

<div id="instructions">
    <b>Interaction:</b> Drag the RED Control Point (representing attention or conversational pressure).<br>
    <b>Observe:</b> Tension builds (sound/color) as the Disc (current state of understanding) resists change. Moving into the unstable central region causes a "Catastrophe"â€”a sudden SNAP to a new equilibrium.<br>
    <b>The Link:</b> Each snap triggers the "More Machine" (right), symbolizing how dynamic shifts generate conceptual proliferation, which exhausts over time.
</div>

<div id="mainContainer">
    <div id="zcmContainer" class="visualization-box">
        <div class="label">Embodied Dynamics (ZCM)</div>
        <svg id="zcmSvg" width="500" height="550"></svg>
    </div>

    <div class="controls-box">
        <label><input type="checkbox" id="toggleMoreMachine"> Show More Machine</label>
        <label><input type="checkbox" id="toggleAcoustic"> Show Acoustic Metaphor</label>
    </div>

    <div id="moreMachineContainer" class="visualization-box" style="display: none;">
        <div class="label">Conceptual Proliferation (More Machine)</div>
        <svg id="moreMachineSvg" width="250" height="250"></svg>
    </div>

    <div id="acousticContainer" class="visualization-box" style="display: none;">
        <div class="label">Acoustic Metaphor</div>
        <svg id="speakerSvg" width="400" height="300"></svg>
    </div>
</div>

<script>
    // === ZCM Configuration ===
    const ZCM_WIDTH = 500;
    const ZCM_HEIGHT = 550;
    const CENTER_X = ZCM_WIDTH / 2;
    const CENTER_Y = ZCM_HEIGHT / 2;
    const DISC_RADIUS = 60;
    const ATTACHMENT_RADIUS = 50; 

    let discAngle = Math.PI / 2; // Current state (pointing down initially)
    let previousDiscAngle = discAngle; // For calculating dTheta
    let controlPoint = { x: CENTER_X + 100, y: CENTER_Y - 100 };
    const fixedPoint = { x: CENTER_X, y: CENTER_Y + 150 }; // Fixed anchor below disc
    
    // === More Machine Configuration ===
    let mmGridData = [];
    let mmSize = 0;
    const MM_MAX_SIZE = 12;
    let mmIteration = 0;
    const MM_SVG_SIZE = 250;

    // === Audio Context ===
    let audioContext;
    let tensionGain;
    let tensionOsc;
    let isInteracting = false; // Tracks if the user is currently dragging
    
    // === Audio Initialization ===
    function initAudio() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            tensionOsc = audioContext.createOscillator();
            tensionGain = audioContext.createGain();
            tensionOsc.connect(tensionGain);
            tensionGain.connect(audioContext.destination);
            tensionOsc.type = 'sawtooth'; // Straining sound
            tensionOsc.frequency.setValueAtTime(80, audioContext.currentTime);
            tensionGain.gain.setValueAtTime(0, audioContext.currentTime); // Start silent
            tensionOsc.start();
        }
    }

    // === ZCM Dynamics (Physics Simulation) ===

    function getAttachmentPoint(angle) {
        return {
            x: CENTER_X + ATTACHMENT_RADIUS * Math.cos(angle),
            y: CENTER_Y + ATTACHMENT_RADIUS * Math.sin(angle)
        };
    }

    // Calculate potential energy (proportional to the square of the spring lengths - Hooke's Law)
    function calculateEnergy(angle) {
        const P = getAttachmentPoint(angle);
        
        // Energy = k * (Length)^2
        const L1_sq = Math.pow(P.x - fixedPoint.x, 2) + Math.pow(P.y - fixedPoint.y, 2);
        const L2_sq = Math.pow(P.x - controlPoint.x, 2) + Math.pow(P.y - controlPoint.y, 2);
        
        return L1_sq + L2_sq;
    }

    // Find the global minimum energy state by searching all angles.
    // This is the core of the ZCM logic: the system instantly seeks the lowest energy state.
    function findEquilibrium() {
        let minEnergy = Infinity;
        let bestAngle = discAngle;
        const searchSteps = 180; // Resolution of search

        for (let i = 0; i < searchSteps; i++) {
            const testAngle = (i / searchSteps) * 2 * Math.PI;
            const energy = calculateEnergy(testAngle);
            if (energy < minEnergy) {
                minEnergy = energy;
                bestAngle = testAngle;
            }
        }
        return { angle: bestAngle, energy: minEnergy };
    }

    function updateDiscState() {
        const equilibrium = findEquilibrium();
        
        // Detect the "Snap" (Catastrophe)
        let angleDiff = equilibrium.angle - discAngle;
        // Normalize the difference to find the shortest path (-PI to PI)
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        let snapped = false;
        // If the angle changes significantly in one step, it means the minimum shifted discontinuously.
        if (Math.abs(angleDiff) > 0.4) { // Threshold for detecting a snap
            snapped = true;
            playSnapSound();
        }

        discAngle = equilibrium.angle;
        updateTensionAudio(equilibrium.energy);
        return snapped;
    }
    
    // === Audio Feedback ===
    // Approximate max energy for normalization
    const MAX_ENERGY = 250000; 

    function updateTensionAudio(energy) {
        if (!audioContext) return;
        
        // Fade out if interaction stops
        if (!isInteracting) {
             tensionGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
             return;
        }
        
        // Map energy to audio parameters
        const normalizedEnergy = Math.min(1, energy / MAX_ENERGY);

        const volume = normalizedEnergy * 0.3;
        const frequency = 80 + normalizedEnergy * 800; // 80Hz to 880Hz

        tensionGain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.05);
        tensionOsc.frequency.linearRampToValueAtTime(frequency, audioContext.currentTime + 0.05);
    }
    
    function playSnapSound() {
        if (!audioContext) return;
        // A sharp, brief sound for the release of energy
        const snap = audioContext.createOscillator();
        const snapGain = audioContext.createGain();
        snap.connect(snapGain);
        snapGain.connect(audioContext.destination);
        snap.type = 'square';
        snap.frequency.setValueAtTime(800, audioContext.currentTime);
        // Rapid frequency drop simulates the physical snap
        snap.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);

        snapGain.gain.setValueAtTime(0.6, audioContext.currentTime);
        snapGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
        snap.start();
        snap.stop(audioContext.currentTime + 0.15);
    }

    // === ZCM Visualization ===
    function drawZCM() {
        const svg = document.getElementById('zcmSvg');
        svg.innerHTML = '';

        // 1. Attachment Point Calculation
        const P = getAttachmentPoint(discAngle);

        // 2. Calculate Tension for Visualization (Color)
        const energy = calculateEnergy(discAngle);
        const tensionNormalized = Math.min(1, energy / MAX_ENERGY);
        // Color map: Light grey (low tension) to dark blue (high tension)
        const tensionLightness = 70 - (tensionNormalized * 30);
        const tensionColor = `hsl(220, 60%, ${tensionLightness}%)`;


        // 3. Elastic Bands (Tension)
        function drawBand(start, end, color) {
            const band = document.createElementNS("http://www.w3.org/2000/svg", "line");
            band.setAttribute('x1', start.x);
            band.setAttribute('y1', start.y);
            band.setAttribute('x2', end.x);
            band.setAttribute('y2', end.y);
            band.setAttribute('stroke', color);
            band.setAttribute('class', 'band');
            svg.appendChild(band);
        }

        drawBand(fixedPoint, P, tensionColor);
        drawBand(controlPoint, P, tensionColor);

        // 4. The Disc (The State)
        const disc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        disc.setAttribute('cx', CENTER_X);
        disc.setAttribute('cy', CENTER_Y);
        disc.setAttribute('r', DISC_RADIUS);
        disc.setAttribute('fill', '#f0f0f0');
        disc.setAttribute('stroke', '#666');
        disc.setAttribute('stroke-width', '1.5');
        svg.appendChild(disc);

        // 4a. Add "M" to the disc
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute('x', CENTER_X);
        text.setAttribute('y', CENTER_Y);
        const angleInDegrees = discAngle * 180 / Math.PI + 90; // +90 to make it upright initially
        text.setAttribute('transform', `rotate(${angleInDegrees}, ${CENTER_X}, ${CENTER_Y})`);
        text.setAttribute('font-family', 'sans-serif');
        text.setAttribute('font-size', '40px');
        text.setAttribute('font-weight', 'bold');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'middle');
        text.setAttribute('fill', '#333');
        text.textContent = 'M';
        svg.appendChild(text);
        
        // 5. Fixed Point (Anchor)
        const fixedP = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        fixedP.setAttribute('cx', fixedPoint.x);
        fixedP.setAttribute('cy', fixedPoint.y);
        fixedP.setAttribute('r', 7);
        fixedP.setAttribute('fill', '#4a90e2'); // A pleasant blue
        svg.appendChild(fixedP);

        // 6. Attachment Point visualization
        const attachP = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        attachP.setAttribute('cx', P.x);
        attachP.setAttribute('cy', P.y);
        attachP.setAttribute('r', 5);
        attachP.setAttribute('fill', '#555');
        svg.appendChild(attachP);

        // 7. Control Point (User Input)
        const controlP = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        controlP.setAttribute('cx', controlPoint.x);
        controlP.setAttribute('cy', controlPoint.y);
        controlP.setAttribute('r', 9);
        controlP.setAttribute('fill', '#d9534f'); // A softer red
        controlP.setAttribute('stroke', '#333');
        controlP.setAttribute('stroke-width', '1');
        svg.appendChild(controlP);
    }

    // === ZCM Interaction Handlers ===
    let isDragging = false;

    function handleStart(e) {
        initAudio();
        isDragging = true;
        isInteracting = true;
        updateControlPoint(e);
    }
    
    function handleMove(e) {
        if (isDragging) {
            updateControlPoint(e);
        }
    }

    function handleEnd() {
        isDragging = false;
        isInteracting = false;
         // Fade out audio when interaction stops
         if (audioContext) {
            tensionGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
        }
    }

    // Mouse Events
    document.getElementById('zcmSvg').addEventListener('mousedown', handleStart);
    document.getElementById('zcmSvg').addEventListener('mousemove', handleMove);
    document.getElementById('zcmSvg').addEventListener('mouseup', handleEnd);

    // Touch Events
    document.getElementById('zcmSvg').addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleStart(e.touches[0]);
    });

    document.getElementById('zcmSvg').addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleMove(e.touches[0]);
    });

    document.getElementById('zcmSvg').addEventListener('touchend', handleEnd);


    function updateControlPoint(e) {
        const rect = document.getElementById('zcmSvg').getBoundingClientRect();
        controlPoint.x = e.clientX - rect.left;
        controlPoint.y = e.clientY - rect.top;
        
        // Constrain movement
        controlPoint.x = Math.max(0, Math.min(ZCM_WIDTH, controlPoint.x));
        controlPoint.y = Math.max(0, Math.min(ZCM_HEIGHT, controlPoint.y));

        // The main animation loop is now responsible for all updates and drawing.
        // This function only needs to update the coordinates.
    }

    // === More Machine Logic and Visualization ===
    function drawMoreMachine() {
        const svg = document.getElementById('moreMachineSvg');
        svg.innerHTML = '';
        const cellSize = MM_SVG_SIZE / MM_MAX_SIZE;
        const svgSize = cellSize * mmSize;
        svg.setAttribute('width', svgSize);
        svg.setAttribute('height', svgSize);

        // Visualization of Exhaustion (Desaturation and loss of contrast)
        const hue = 20; // Orange hue
        const saturation = Math.max(0, 100 - mmIteration * 10);
        // Dark color gets lighter, light color gets darker -> Fading to gray
        const lightness1 = Math.min(95, 40 + mmIteration * 5);
        const lightness0 = Math.max(40, 85 - mmIteration * 5);

        for (let i = 0; i < mmSize; i++) {
            for (let j = 0; j < mmSize; j++) {
                const value = mmGridData[i][j];
                const color = value === 1 ? `hsl(${hue}, ${saturation}%, ${lightness1}%)` : `hsl(${hue}, ${saturation}%, ${lightness0}%)`;
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('x', j * cellSize);
                rect.setAttribute('y', i * cellSize);
                rect.setAttribute('width', cellSize);
                rect.setAttribute('height', cellSize);
                rect.setAttribute('fill', color);
                rect.setAttribute('stroke', '#aaa');
                rect.setAttribute('stroke-width', '0.5');
                svg.appendChild(rect);
            }
        }
    }

    // The Diagonalization Algorithm
    function generateMore() {
        if (mmSize >= MM_MAX_SIZE) {
            return;
        }
        
        mmIteration++;

        if (mmSize === 0) {
            // Initialize if empty
            mmGridData = [[Math.round(Math.random())]];
            mmSize = 1;
        } else {
            // Diagonalization (The Critique)
            let newPattern = [];
            for (let i = 0; i < mmSize; i++) {
                // Flip the diagonal
                newPattern.push(1 - mmGridData[i][i]);
            }

            // Proliferation (The "More")
            mmGridData.push(newPattern);
            mmSize++;

            // Fill out the square randomly to maintain structure for the next iteration
            for (let i = 0; i < mmSize - 1; i++) {
                mmGridData[i].push(Math.round(Math.random()));
            }
            mmGridData[mmSize-1].push(Math.round(Math.random()));
        }

        drawMoreMachine();
    }

    // === Speaker/Acoustic Metaphor Visualization ===
    let speakerSvg, pistonRect, airParticles = [];
    const numAirParticles = 200;
    const particleRadius = 1.5;
    const speakerBaseX = 50;
    const speakerWidth = 30;
    const speakerHeight = 100;
    const speakerY = 100;
    const chamberEndX = 380;
    const waveSpeed = 4;
    const historySeconds = 1.5;
    const fps = 60;
    const speakerHistory = new Array(Math.ceil(fps * historySeconds)).fill(0);
    let historyIndex = 0;
    const maxSpeakerDisplacement = 35;
    const sensitivityScale = 10;
    let smoothedDisplacement = 0;
    const smoothingFactor = 0.15; // Lower is smoother

    function initSpeakerSvg() {
        speakerSvg = document.getElementById('speakerSvg');
        if (!speakerSvg) return;
        const svgNS = "http://www.w3.org/2000/svg";
        speakerSvg.innerHTML = '';

        let wallTop = document.createElementNS(svgNS, 'line');
        wallTop.setAttribute('x1', speakerBaseX); wallTop.setAttribute('y1', speakerY);
        wallTop.setAttribute('x2', chamberEndX); wallTop.setAttribute('y2', speakerY);
        wallTop.setAttribute('stroke', '#999'); wallTop.setAttribute('stroke-width', '1');
        speakerSvg.appendChild(wallTop);
        let wallBottom = document.createElementNS(svgNS, 'line');
        wallBottom.setAttribute('x1', speakerBaseX); wallBottom.setAttribute('y1', speakerY + speakerHeight);
        wallBottom.setAttribute('x2', chamberEndX); wallBottom.setAttribute('y2', speakerY + speakerHeight);
        wallBottom.setAttribute('stroke', '#999'); wallBottom.setAttribute('stroke-width', '1');
        speakerSvg.appendChild(wallBottom);

        pistonRect = document.createElementNS(svgNS, 'rect');
        pistonRect.setAttribute('x', speakerBaseX - speakerWidth);
        pistonRect.setAttribute('y', speakerY);
        pistonRect.setAttribute('width', speakerWidth);
        pistonRect.setAttribute('height', speakerHeight);
        pistonRect.setAttribute('fill', '#aaa');
        pistonRect.setAttribute('stroke', '#666');
        speakerSvg.appendChild(pistonRect);

        const particleGroup = document.createElementNS(svgNS, 'g');
        speakerSvg.appendChild(particleGroup);
        const startX = speakerBaseX + particleRadius + 15;
        const endX = chamberEndX - particleRadius - 15;
        const startY = speakerY + particleRadius + 10;
        const endY = speakerY + speakerHeight - particleRadius - 10;
        const numX = Math.ceil(Math.sqrt(numAirParticles * (endX - startX) / (endY - startY)));
        const numY = Math.ceil(numAirParticles / numX);
        const stepX = (numX > 1) ? (endX - startX) / (numX - 1) : 0;
        const stepY = (numY > 1) ? (endY - startY) / (numY - 1) : 0;

        for (let i = 0; i < numX; i++) {
            for (let j = 0; j < numY; j++) {
                if (airParticles.length >= numAirParticles) break;
                let baseX = startX + i * stepX + (Math.random() - 0.5) * (stepX || 10) * 0.4;
                let baseY = startY + j * stepY + (Math.random() - 0.5) * (stepY || 10) * 0.4;
                let circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('cx', baseX.toFixed(1));
                circle.setAttribute('cy', baseY.toFixed(1));
                circle.setAttribute('r', particleRadius);
                circle.setAttribute('fill', '#5a8fcd');
                circle.setAttribute('opacity', '0.7');
                particleGroup.appendChild(circle);
                airParticles.push({ element: circle, baseX: baseX, baseY: baseY });
            }
        }
    }

    function animateSpeaker() {
        if (!speakerSvg || !document.getElementById('toggleAcoustic').checked) return;

        let dTheta = discAngle - previousDiscAngle;
        while (dTheta > Math.PI) dTheta -= 2 * Math.PI;
        while (dTheta < -Math.PI) dTheta += 2 * Math.PI;

        const targetDisplacement = maxSpeakerDisplacement * Math.tanh(dTheta * sensitivityScale);

        // Apply smoothing
        smoothedDisplacement += (targetDisplacement - smoothedDisplacement) * smoothingFactor;

        speakerHistory[historyIndex] = smoothedDisplacement;
        historyIndex = (historyIndex + 1) % speakerHistory.length;

        pistonRect.setAttribute('x', (speakerBaseX - speakerWidth + smoothedDisplacement).toFixed(1));

        const currentHistoryIndex = historyIndex;
        for (let p of airParticles) {
            const distance = p.baseX - speakerBaseX;
            const timeDelay = distance / waveSpeed;
            let lookBackIndex = Math.round(currentHistoryIndex - 1 - timeDelay);
            lookBackIndex = (lookBackIndex % speakerHistory.length + speakerHistory.length) % speakerHistory.length;
            const historicalDisplacement = speakerHistory[lookBackIndex] || 0;
            const damping = Math.exp(-0.004 * distance);
            const currentX = p.baseX + historicalDisplacement * damping;
            const pistonFaceX = speakerBaseX - speakerWidth + smoothedDisplacement;

            const clampedX = Math.max(
                pistonFaceX + speakerWidth + particleRadius,
                Math.min(chamberEndX - particleRadius, currentX)
            );
            p.element.setAttribute('cx', clampedX.toFixed(1));
        }

        previousDiscAngle = discAngle;
    }

    // === Main Animation Loop ===
    function mainLoop() {
        // Only update ZCM when user is interacting
        if (isInteracting) {
            const snapped = updateDiscState();
            drawZCM();
            if (snapped && document.getElementById('toggleMoreMachine').checked) {
                generateMore();
            }
        }

        // Always run speaker animation, but the function checks if it's visible
        animateSpeaker();

        requestAnimationFrame(mainLoop);
    }

    // === Initialization ===
    drawZCM();
    drawMoreMachine(); // Draw it once to initialize the data, even though it's hidden

    function setupControls() {
        const toggleMoreMachine = document.getElementById('toggleMoreMachine');
        const toggleAcoustic = document.getElementById('toggleAcoustic');
        const moreMachineContainer = document.getElementById('moreMachineContainer');
        const acousticContainer = document.getElementById('acousticContainer');

        if (toggleMoreMachine && moreMachineContainer) {
            toggleMoreMachine.addEventListener('change', (e) => {
                moreMachineContainer.style.display = e.target.checked ? 'flex' : 'none';
            });
        }

        if (toggleAcoustic && acousticContainer) {
            toggleAcoustic.addEventListener('change', (e) => {
                acousticContainer.style.display = e.target.checked ? 'flex' : 'none';
                if (e.target.checked && !speakerSvg) { // Initialize only once
                    initSpeakerSvg();
                }
            });
        }
    }

    // Defer setup until DOM is loaded
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", setupControls);
    } else {
        setupControls();
    }

    mainLoop();

</script>
</body>
</html>