/** <module> Mechanisms of Critique (Analysis of Pathology and Sublation)
 *
 *  This module implements the mechanisms for identifying and critiquing
 *  pathologies (Fixation, Alienation, Bad Infinite) and the process of
 *  Sublation (Letting Go, Accommodation).
 *
 *  It integrates the functions of the legacy Reflective Monitor (detection)
 *  and Reorganization Engine (accommodation).
 *
 *  (Synthesis_1, Chapter 4.5)
 */
:- module(critique,
          [
            reflect/2,
            accommodate/1,
            get_stress_map/1,
            reset_stress_map/0
          ]).

% Import operators - must be declared before use
:- op(1050, xfy, =>).
:- op(500, fx, comp_nec).
:- op(500, fx, exp_nec).
:- op(500, fx, exp_poss).
:- op(500, fx, comp_poss).
:- op(500, fx, neg).

:- use_module(incompatibility_semantics, [incoherent/1]).
:- use_module(pml_operators).
% Used for identifying the structure of the Bad Infinite.
:- use_module(utils, [select/3]).

:- dynamic stress/2.

% =================================================================
% Part 1: Reflection (Detection of Disequilibrium and Pathology)
% =================================================================

%!      reflect(+Proof, -DisequilibriumTrigger) is semidet.
%
%       Analyzes a proof structure to detect disequilibrium or pathology.
%       Succeeds if a trigger is found.
%
%       @param Proof The proof structure generated by the prover.
%       @param DisequilibriumTrigger A term describing the issue.
reflect(Proof, Trigger) :-
    % 1. Analyze the proof structure for pathologies (e.g., Bad Infinite).
    ( detect_pathology(Proof, Trigger) -> true
    ;
    % 2. Extract commitments and check for incoherence.
      extract_commitments(Proof, Commitments),
      ( incoherent(Commitments) -> Trigger = incoherence(Commitments)
      ; fail % Equilibrium
      )
    ).

% --- Pathology Detection ---

%!  detect_pathology(+Proof, -Pathology) is semidet.
%
%   Analyzes the proof structure for known pathological patterns.
detect_pathology(Proof, pathology(bad_infinite, Cycle)) :-
    % Detects a Bad Infinite: a closed cycle mediated exclusively by compressive necessity (Box_down).
    % (Synthesis_1, Definition 1)
    find_proof_cycle(Proof, Cycle),
    is_bad_infinite(Cycle), !.

%!  find_proof_cycle(+Proof, -Cycle) is nondet.
%
%   Detects cycles in the proof tree by tracking visited states.
%   A cycle exists when we re-prove the same sequent via the same rule.
find_proof_cycle(Proof, Cycle) :-
    find_cycle_impl(Proof, [], Cycle).

find_cycle_impl(proof(RuleName, Sequent, SubProofs), Visited, Cycle) :-
    Node = node(RuleName, Sequent),
    ( member(Node, Visited) ->
        % Found a cycle! Extract it.
        extract_cycle(Node, [Node|Visited], Cycle)
    ;
        % Continue searching in subproofs
        member(SubProof, SubProofs),
        find_cycle_impl(SubProof, [Node|Visited], Cycle)
    ).
find_cycle_impl(erasure(_), _, _) :- fail.

%!  extract_cycle(+StartNode, +Path, -Cycle) is det.
%
%   Extracts the cycle portion from the path.
extract_cycle(Node, Path, Cycle) :-
    extract_cycle_impl(Node, Path, [], Cycle).

extract_cycle_impl(Node, [Node|_], Acc, Cycle) :-
    reverse([Node|Acc], Cycle).
extract_cycle_impl(TargetNode, [Node|Rest], Acc, Cycle) :-
    Node \= TargetNode,
    extract_cycle_impl(TargetNode, Rest, [Node|Acc], Cycle).

% Helper to verify if a cycle is a Bad Infinite (all compressive).
is_bad_infinite(Cycle) :-
    Cycle \= [],
    forall(member(Node, Cycle), is_compressive_node(Node)).

is_compressive_node(node(pml_rhythm(_), _)).
is_compressive_node(node(RuleName, _)) :-
    functor(RuleName, pml_rhythm, 1).
% Could add more patterns as needed


% --- Commitment Extraction ---

% Extracts the set of axioms (material inferences) used in the proof.
extract_commitments(Proof, Commitments) :-
    extract_commitments_recursive(Proof, C_Nested),
    flatten(C_Nested, C_Flat),
    list_to_set(C_Flat, Commitments).

extract_commitments_recursive(erasure(_), []). % Erased proofs have no commitments.
extract_commitments_recursive(proof(RuleName, _Sequent, SubProofs), Commitments) :-
    % If the rule is a Modus Ponens (MMP), the axiom used is the commitment.
    ( RuleName = mmp(Axiom) -> Commitment = [Axiom] ; Commitment = [] ),
    maplist(extract_commitments_recursive, SubProofs, SubCommitments),
    append(Commitment, SubCommitments, Commitments).


% =================================================================
% Part 2: Accommodation (Sublation and Reorganization)
% =================================================================

%!      accommodate(+Trigger:term) is semidet.
%
%       Attempts to accommodate a state of disequilibrium by modifying the
%       system's state or knowledge base. This is the process of Sublation (Aufhebung).
%
%       @param Trigger The term describing the disequilibrium.
accommodate(perturbation(resource_exhaustion, Sequent)) :-
    !,
    format('Handling Resource Exhaustion for: ~w~n', [Sequent]),
    % Strategy 1: Record the failure for learning
    term_string(Sequent, SeqStr),
    increment_stress(SeqStr),
    format('  Incremented stress for: ~w~n', [SeqStr]),
    % Strategy 2: Try to introduce a lemma (caching the result)
    % For now, we just acknowledge and fail to trigger external handling
    writeln('  Resource exhaustion recorded. External intervention required.'),
    fail.

accommodate(incoherence(Commitments)) :-
    !,
    format('Handling Incoherence in Commitments: ~w~n', [Commitments]),
    % Strategy: Belief Revision. Identify and retract the "weakest" commitment.
    % Weakness can be determined by the conceptual stress map.
    handle_incoherence(Commitments).

accommodate(pathology(bad_infinite, Cycle)) :-
    !,
    format('Handling Bad Infinite (Pathological Cycle): ~w~n', [Cycle]),
    % Strategy: Sublation (Aufhebung) - Introduce a higher-level concept
    % that subsumes the oscillation (e.g., Hegel's "Becoming" subsumes Being/Nothing)

    % Extract the oscillating elements from the cycle
    findall(Sequent, member(node(_, Sequent), Cycle), Sequents),
    format('  Detected oscillation between: ~w~n', [Sequents]),

    % For now: Record the pathology and suggest the need for conceptual elevation
    writeln('  SUBLATION REQUIRED: Introduce higher-level concept to resolve oscillation'),
    writeln('  Example: Being <-> Nothing requires "Becoming"'),
    writeln('  System cannot auto-generate new concepts yet.'),

    % Record each transition as problematic
    forall(member(node(RuleName, Seq), Cycle),
           (term_string(Seq, SeqStr),
            increment_stress(SeqStr),
            format('    Marked as stressed: ~w via ~w~n', [SeqStr, RuleName]))),

    % Fail to signal external intervention needed
    writeln('  External conceptual intervention required.'),
    fail.

accommodate(Trigger) :-
    format('Unknown trigger type: ~w. Cannot accommodate.~n', [Trigger]),
    fail.

% --- Incoherence Handling (Belief Revision) ---

handle_incoherence(Commitments) :-
    % 1. Identify the most stressed commitment.
    identify_stressed_commitment(Commitments, StressedCommitment),
    % 2. Retract/Modify the problematic commitment.
    format('Retracting/Modifying stressed commitment: ~w~n', [StressedCommitment]),
    retract_commitment(StressedCommitment).

identify_stressed_commitment(Commitments, StressedCommitment) :-
    % Score each commitment by its stress level
    findall(score(Stress, Commitment),
            (member(Commitment, Commitments),
             commitment_stress(Commitment, Stress)),
            Scores),
    % Sort by stress (highest first)
    ( Scores \= [] ->
        sort(1, @>=, Scores, [score(_, StressedCommitment)|_])
    ;
        % Fallback: pick first commitment if no stress data
        Commitments = [StressedCommitment|_]
    ).

%!  commitment_stress(+Commitment, -Stress) is det.
%
%   Calculate stress for a commitment based on failure history.
commitment_stress((Antecedents => Consequent), Stress) :-
    % Create a signature for this commitment
    term_string(Antecedents, AntStr),
    term_string(Consequent, ConsStr),
    atomic_list_concat([AntStr, ' => ', ConsStr], Signature),
    % Look up stress
    ( stress(Signature, Stress) -> true ; Stress = 0 ).

retract_commitment(Commitment) :-
    % Dynamic retraction: assert a blocking rule that prevents this commitment from firing
    format('Blocking problematic commitment: ~w~n', [Commitment]),
    Commitment = (Antecedents => Consequent),
    % Assert a new incoherence rule: if these antecedents hold, mark as incoherent
    assertz(incompatibility_semantics:is_incoherent(Antecedents)),
    format('  Asserted: is_incoherent(~w)~n', [Antecedents]).

% =================================================================
% Part 3: Conceptual Stress Map (Failure Tracking)
% =================================================================
% (Salvaged from reflective_monitor.pl)

increment_stress(Signature) :-
    (   retract(stress(Signature, Count))
    ->  NewCount is Count + 1
    ;   NewCount = 1
    ),
    assertz(stress(Signature, NewCount)).

get_stress_map(Map) :-
    findall(stress(Signature, Count), stress(Signature, Count), Map).

reset_stress_map :-
    retractall(stress(_, _)).
