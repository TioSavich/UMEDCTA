% Filename: more_machine_learner.pl (The Protein-Folding Learner V3)
:- module(more_machine_learner,
          [ critique_and_bootstrap/1,
            explore/1,
            run_learned_strategy/5,
            solve/4
          ]).

% Use the semantics engine
:- use_module(incompatibility_semantics, [proves/1, set_domain/1, current_domain/1, obj_coll/1, normalize/2]).
:- use_module(library(random)).
:- use_module(library(lists)). % For nth1/3 etc.

% Ensure operators are visible
:- op(1050, xfy, =>).
:- op(500, fx, neg).
:- op(550, xfy, rdiv).

% Dynamic predicate for learned strategies.
% run_learned_strategy(A, B, Result, StrategyName, Trace)
% Arity increased to 5 to include the Trace generated by the strategy itself.
:- dynamic run_learned_strategy/5.

% =================================================================
% Part 0: Initialization and Persistence
% =================================================================

knowledge_file('learned_knowledge.pl').

% Initialization: Load persistent knowledge when this module is loaded.
:- initialization(load_knowledge, now).

load_knowledge :-
    knowledge_file(File),
    (   exists_file(File)
    ->  % Load the file. The clauses for run_learned_strategy/5 will be asserted.
        consult(File),
        % Count loaded strategies for reporting
        findall(_, clause(run_learned_strategy(_,_,_,_,_), _), Clauses),
        length(Clauses, Count),
        format('~N[Learner Init] Successfully loaded ~w learned strategies.~n', [Count])
    ;   format('~N[Learner Init] Knowledge file not found. Starting fresh.~n')
    ).

save_knowledge :-
    knowledge_file(File),
    % Open the file and write the dynamic predicates.
    setup_call_cleanup(
        open(File, write, Stream),
        (
            writeln(Stream, '% Automatically generated knowledge base.'),
            writeln(Stream, ':- op(550, xfy, rdiv).'),
            % Iterate over the clauses and write them using portray_clause for correct formatting.
            forall(clause(run_learned_strategy(A, B, R, S, T), Body),
                   portray_clause(Stream, (run_learned_strategy(A, B, R, S, T) :- Body)))
        ),
        close(Stream)
    ).

% =================================================================
% Part 1: The Generative-Reflective Loop (Exploration)
% =================================================================

explore(addition) :-
    writeln('====================================================='),
    writeln('--- Autonomous Exploration Initiated: Addition (Protein Folding) ---'),
    current_domain(D),
    format('Current Semantic Domain: ~w~n', [D]),
    (member(D, [n, z, q]) ->
        explore_addition_loop(50)
    ;
        writeln('Exploration requires domain (n, z, or q).')
    ).

explore_addition_loop(0) :-
    writeln('\nExploration limit reached. Saving knowledge base...'),
    save_knowledge,
    writeln('Knowledge base saved.'),
    writeln('====================================================='), !.
explore_addition_loop(I) :-
    % 1. GENERATE: Create a candidate problem.
    generate_addition_problem(A, B),
    normalize(A, AN), normalize(B, BN),
    format('\n[Cycle ~w] Exploring Problem: ~w + ~w~n', [I, AN, BN]),

    % 2. SEARCH & REFLECT: Discover strategies based on the CURRENT BEST solution path.
    (   discover_strategy(A, B, StrategyName)
    ->  format('-> Strategy Discovery Processed: ~w~n', [StrategyName])
    ;   true
    ),
    NextI is I - 1,
    explore_addition_loop(NextI).

% Problem Generation (Heuristic)
generate_addition_problem(A, B) :-
    random_between(3, 12, A),
    (   random(R), R < 0.3 % 30% chance of generating a double
    ->  B = A
    ;   random_between(3, 15, B)
    ).

% =================================================================
% Part 2: The Unified Solver (Strategy Hierarchy)
% =================================================================

% solve(+A, +B, -Result, -Trace)
% Implements the strategy hierarchy: Learned Strategies -> Foundational.
solve(A, B, Result, Trace) :-
    % Level 1: Try learned strategies (Dynamically asserted)
    (   run_learned_strategy(A, B, Result, _StrategyName, Trace)
    ->  true
    ;   % Level 0: Fall back to foundational abilities.
        solve_foundationally(A, B, Result, Trace)
    ).

% =================================================================
% Part 3: Strategy Discovery (The Core Learner)
% =================================================================

discover_strategy(A, B, StrategyName) :-
    % 1. GENERATIVE PHASE: Solve using the BEST available strategy (Bootstrapping).
    solve(A, B, Result, Trace),
    count_trace_steps(Trace, TraceLength),
    format('  Solution found via [~w]: ~w. Steps: ~w~n', [Trace.strategy, Result, TraceLength]),

    % 2. REFLECTIVE PHASE: Analyze the trace for patterns.
    % Use backtracking (;) to allow multiple strategies to be discovered from the same trace.
    (   detect_cob_pattern(Trace, _), StrategyName = cob,
        construct_and_validate_cob(A, B)
    ;   detect_rmb_pattern(Trace, RMB_Data), StrategyName = rmb,
        construct_and_validate_rmb(A, B, RMB_Data)
    ;   detect_doubles_pattern(Trace, _), StrategyName = doubles,
        construct_and_validate_doubles(A, B)
    ;   fail % Fails if no patterns are detected, handled by the explore loop.
    ).

% --- 3.1 Foundational Ability: Counting ---

successor(X, Y) :- proves([] => [o(plus(X, 1, Y))]).

solve_foundationally(A, B, Result, Trace) :-
    % Constraints for the foundational counting strategy
    obj_coll(A), obj_coll(B),
    integer(A), integer(B), B >= 0,
    count_loop(A, B, Result, Steps),
    % Define the trace structure using Prolog dicts.
    Trace = trace{a_start:A, b_start:B, strategy:counting, steps:Steps}.

count_loop(CurrentA, 0, CurrentA, []) :- !.
count_loop(CurrentA, CurrentB, Result, [step(CurrentA, NextA)|Steps]) :-
    CurrentB > 0,
    NextB is CurrentB - 1,
    successor(CurrentA, NextA),
    count_loop(NextA, NextB, Result, Steps).

% --- 3.2 Trace Analysis Helpers ---

% Helper to count steps, handling wrapped traces.
count_trace_steps(Trace, Count) :-
    (   member(Trace.strategy, [counting, doubles, rmb(_)])
    ->  length(Trace.steps, Count)
    ;   Trace.strategy = cob
    ->  % COB wraps another trace in its steps. Find the inner trace.
        ( member(inner_trace(InnerTrace), Trace.steps)
          -> count_trace_steps(InnerTrace, Count)
          ; Count = 0 % Should not happen
        )
    ;   Count = 1 % Default for unknown strategies
    ).

% Helper to extract the underlying calculation trace if wrapped (e.g., by COB).
get_calculation_trace(T, T) :- member(T.strategy, [counting, rmb(_), doubles]).
get_calculation_trace(T, CT) :-
    T.strategy = cob,
    member(inner_trace(InnerT), T.steps),
    get_calculation_trace(InnerT, CT).

% =================================================================
% Part 4: Pattern Detection & Construction
% =================================================================

% PATTERN 1: Counting On Bigger (COB) - Exploiting Commutativity

detect_cob_pattern(Trace, cob_data) :-
    % Detect if the current strategy is inefficient counting (A < B).
    Trace.strategy = counting,
    A = Trace.a_start, B = Trace.b_start,
    integer(A), integer(B),
    A < B.

construct_and_validate_cob(A, B) :-
    StrategyName = cob,
    % Head structure: run_learned_strategy(A_in, B_in, Result, StrategyName, Trace)
    StrategyHead = run_learned_strategy(A_in, B_in, Result, StrategyName, Trace),
    StrategyBody = (
        integer(A_in), integer(B_in),
        % Determine the optimal order at runtime.
        (A_in >= B_in -> Start = A_in, Count = B_in, Swap = no_swap ; Start = B_in, Count = A_in, Swap = swapped(B_in, A_in)),

        % Semantic Validation (Crucial for COB): Ensure commutativity holds before relying on the swap.
        (   Swap = swapped(_, _) ->
            (proves([n(plus(A_in, B_in, R_temp))] => [n(plus(B_in, A_in, R_temp))]) -> true ; fail)
            ; true
        ),
        
        % Execution: Use the foundational solver with the optimized inputs.
        % COB specifically optimizes the foundational action.
        solve_foundationally(Start, Count, Result, InnerTrace),
        % Wrap the trace to record the COB action.
        Trace = trace{a_start:A_in, b_start:B_in, strategy:StrategyName, steps:[Swap, inner_trace(InnerTrace)]}
    ),
    validate_and_assert(A, B, StrategyHead, StrategyBody).


% PATTERN 2: Rearranging to Make Bases (RMB)

detect_rmb_pattern(TraceWrapper, rmb_data{k:K, base:Base}) :-
    % Check if the underlying calculation used counting.
    get_calculation_trace(TraceWrapper, Trace),
    Trace.strategy = counting,
    Base = 10,
    A = Trace.a_start, B = Trace.b_start,
    integer(A), integer(B),
    A > 0, A < Base, K is Base - A, B >= K,
    % Reflection: Check if the counting trace crosses the bridge exactly at the K-th step
    nth1(K, Trace.steps, Step),
    Step = step(_, Base).

construct_and_validate_rmb(A, B, RMB_Data) :-
    Base = RMB_Data.base,
    StrategyName = rmb(Base),
    StrategyHead = run_learned_strategy(A_in, B_in, Result, StrategyName, Trace),
    StrategyBody = (
        % Preconditions
        integer(A_in), integer(B_in),
        A_in > 0, A_in < Base, K_runtime is Base - A_in, B_in >= K_runtime,
        % Efficient Execution
        B_new_runtime is B_in - K_runtime,
        Result is Base + B_new_runtime,
        % Generate the efficient trace structure
        Trace = trace{a_start:A_in, b_start:B_in, strategy:StrategyName, steps:[step(A_in, Base), step(Base, Result)]}
    ),
    validate_and_assert(A, B, StrategyHead, StrategyBody).

% PATTERN 3: Doubles (Generalized Rote Knowledge)

detect_doubles_pattern(TraceWrapper, doubles_data) :-
    % Check if the underlying calculation was less efficient (e.g., counting or RMB).
    get_calculation_trace(TraceWrapper, Trace),
    member(Trace.strategy, [counting, rmb(_)]),
    A = Trace.a_start, B = Trace.b_start,
    A == B, integer(A).

construct_and_validate_doubles(A, B) :-
    StrategyName = doubles,
    StrategyHead = run_learned_strategy(A_in, B_in, Result, StrategyName, Trace),
    StrategyBody = (
        % Preconditions
        integer(A_in), A_in == B_in,
        % Efficient Execution
        Result is A_in * 2,
        % Generate the efficient trace
        Trace = trace{a_start:A_in, b_start:B_in, strategy:StrategyName, steps:[rote(Result)]}
    ),
    validate_and_assert(A, B, StrategyHead, StrategyBody).


% --- Validation Helper ---

validate_and_assert(A, B, StrategyHead, StrategyBody) :-
    % VALIDATION: Ensure the strategy is sound for the input case before generalization.
    copy_term((StrategyHead, StrategyBody), (ValidationHead, ValidationBody)),
    % Bind inputs for validation (A_in, B_in, Result, StrategyName, Trace)
    arg(1, ValidationHead, A),
    arg(2, ValidationHead, B),
    arg(3, ValidationHead, CalculatedResult),
    arg(4, ValidationHead, StrategyName),

    (   call(ValidationBody),
        % Verify against the semantics (ensuring coherence)
        proves([] => [o(plus(A, B, CalculatedResult))])
    ->  % Assert the new strategy if not already learned.
        (   clause(run_learned_strategy(_, _, _, StrategyName, _), _)
        ->  format('  (Strategy ~w already known)~n', [StrategyName])
        ;   assertz((StrategyHead :- StrategyBody)),
            format('  -> New Strategy Asserted: ~w~n', [StrategyName])
        )
    ;   writeln('ERROR: Strategy validation failed. Not asserted.')
    ).

% =================================================================
% Part 5: Normative Critique (Placeholder)
% =================================================================
critique_and_bootstrap(_) :- writeln('Normative Critique Placeholder.').