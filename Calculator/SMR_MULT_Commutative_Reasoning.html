<!DOCTYPE html>
<html>
<head>
    <title>Commutative Multiplication</title>
<link rel="stylesheet" href="strategy_styles.css">
    <!-- MathJax for mathematical notation -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    
<div class="container">
    <button class="back-button" onclick="window.location.href='index.html'">‚Üê Back to Calculator</button>

<h1>Commutative Reasoning for Multiplication</h1>

    <div>
        <label for="commuteA">Factor 1:</label>
        <input type="number" id="commuteA" value="10">
    </div>
    <div>
        <label for="commuteB">Factor 2:</label>
        <input type="number" id="commuteB" value="7">
    </div>

    <button onclick="runCommutativeAutomaton()">Repackage and Visualize</button>

    <div id="commuteOutput">
        <!-- Output will be displayed here -->
    </div>

        <button class="pdf-button" class="pdf-button" onclick="openPdfViewer()">üìÑ Learn More: View Detailed PDF Documentation</button>

    <script>
        function openPdfViewer() {
            // Opens the PDF documentation for the strategy.
            window.open('./SMR_MULT_COMMUTATIVE_REASONING.pdf', '_blank');
        }
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const commuteOutputElement = document.getElementById('commuteOutput');
            const commuteAInput = document.getElementById('commuteA');
            const commuteBInput = document.getElementById('commuteB');

            window.runCommutativeAutomaton = function() {
                try {
                    const factorA = commuteAInput.value;
                    const factorB = commuteBInput.value;

                    if (isNaN(parseInt(factorA)) || isNaN(parseInt(factorB)) || parseInt(factorA) <= 0 || parseInt(factorB) <= 0) {
                        commuteOutputElement.textContent = "Please enter valid positive numbers for both factors";
                        return;
                    }

                    let output = '';
                    output += `<h2>Commutative Repackaging for Multiplication</h2>\n\n`;
                    output += `<p><strong>Original Expression:</strong> ${factorA} &times; ${factorB}</p>\n`; // Updated to display the multiplication symbol correctly

                    // --- Simulate FST Transformation ---
                    const transformedFactorA = factorB;
                    const transformedFactorB = factorA;

                    output += `<p><strong>Applying Commutative Repackaging...</strong></p>\n`;
                    output += `<p>We transform the expression by swapping the order of the factors.</p>\n`;
                    output += `<p><strong>Repackaged Expression:</strong> ${transformedFactorA} &times; ${transformedFactorB}</p>\n\n`;

                    // --- Visualize with Colorful Cubes ---
                    const numFactorA = parseInt(factorA);
                    const numFactorB = parseInt(factorB);
                    const productAB = numFactorA * numFactorB;
                    const productBA = parseInt(transformedFactorA) * parseInt(transformedFactorB);

                    output += `<p><strong>Visualizing the Repackaging:</strong></p>\n`;

                    // Arrangement 1 (Original: A x B) - Cubes
                    output += `<p><strong>Arrangement 1: ${factorA} groups of ${factorB} items each</strong></p>\n`;
                    output += `<p>Visual representation:</p>\n`;
                    for (let i = 0; i < numFactorA; i++) {
                        output += `<div class='cube-row'>`; // Start a new row for cubes
                        for (let j = 0; j < numFactorB; j++) {
                            const rainbowColors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
                            const colorClass = rainbowColors[j % rainbowColors.length]; // Cycle through rainbow colors
                            output += `<span class='cube ${colorClass}'></span>`; // Create a cube with color class
                        }
                        output += `</div>`; // End the cube row
                    }
                    output += `<p>Total: ${productAB} items</p>\n\n`;

                    // Arrangement 2 (Repackaged: B x A) - Cubes
                    output += `<p><strong>Arrangement 2: ${transformedFactorA} groups of ${transformedFactorB} items each</strong></p>\n`;
                    output += `<p>Visual representation:</p>\n`;
                    for (let i = 0; i < parseInt(transformedFactorA); i++) {
                        output += `<div class='cube-row'>`; // Start a new row
                        for (let j = 0; j < parseInt(transformedFactorB); j++) {
                            const rainbowColors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
                            const colorClass = rainbowColors[j % rainbowColors.length];
                            output += `<span class='cube ${colorClass}'></span>`; // Create colored cube
                        }
                        output += `</div>`; // End row
                    }
                    output += `<p>Total: ${productBA} items</p>\n\n`;


                    output += `<p><strong>Conclusion:</strong></p>\n`;
                    output += `<p>By commutatively repackaging ${factorA} &times; ${factorB} into ${transformedFactorA} &times; ${transformedFactorB}, we change the grouping but maintain the same total quantity (${productAB} = ${productBA}).</p>\n`;


                    commuteOutputElement.innerHTML = output;


                } catch (error) {
                    commuteOutputElement.textContent = `Error: ${error.message}`;
                }
            };
        });
    </script>
</div>

</body>
</html>