\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} FSM Engine for Strategy Execution}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module provides a generic Finite State Machine (FSM) execution engine}
\PYG{c+cm}{ * for running arithmetic strategies. It coordinates with the dialectical\PYGZus{}engine}
\PYG{c+cm}{ * in the core framework while providing domain\PYGZhy{}specific extensions for}
\PYG{c+cm}{ * arithmetic operations.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @author UMEDCA System}
\PYG{c+cm}{ * @license MIT}
\PYG{c+cm}{ */}

\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{fsm\PYGZus{}engine}\PYG{p}{,} \PYG{p}{[}
    \PYG{l+s+sAtom}{run\PYGZus{}fsm\PYGZus{}with\PYGZus{}base}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{,}
    \PYG{l+s+sAtom}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}history}\PYG{o}{/}\PYG{l+m+mi}{2}
\PYG{p}{]).}

\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{grounded\PYGZus{}arithmetic}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{incur\PYGZus{}cost}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{]).}

\PYG{c+c1}{\PYGZpc{}! run\PYGZus{}fsm\PYGZus{}with\PYGZus{}base(+Module, +InitialState, +Parameters, +Base, \PYGZhy{}History) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} Runs an FSM strategy with base\PYGZhy{}10 tracking. This is a wrapper around}
\PYG{c+c1}{\PYGZpc{} the generic FSM runner that adds arithmetic\PYGZhy{}specific context.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} @param Module The module containing the FSM definition (transition/3, accept\PYGZus{}state/1, etc.)}
\PYG{c+c1}{\PYGZpc{} @param InitialState The starting state of the FSM}
\PYG{c+c1}{\PYGZpc{} @param Parameters Additional parameters for the strategy (e.g., [A, B, Base])}
\PYG{c+c1}{\PYGZpc{} @param Base The number base being used (typically 10)}
\PYG{c+c1}{\PYGZpc{} @param History The execution history (list of steps)}
\PYG{c+c1}{\PYGZpc{}}
\PYG{n+nf}{run\PYGZus{}fsm\PYGZus{}with\PYGZus{}base}\PYG{p}{(}\PYG{n+nv}{Module}\PYG{p}{,} \PYG{n+nv}{InitialState}\PYG{p}{,} \PYG{n+nv}{Parameters}\PYG{p}{,} \PYG{n+nv}{Base}\PYG{p}{,} \PYG{n+nv}{History}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{fsm\PYGZus{}initialization}\PYG{p}{),}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}  [FSM Engine] Running \PYGZti{}w with base \PYGZti{}w\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{Module}\PYG{p}{,} \PYG{n+nv}{Base}\PYG{p}{]),}
    \PYG{n+nf}{run\PYGZus{}fsm\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{Module}\PYG{p}{,} \PYG{n+nv}{InitialState}\PYG{p}{,} \PYG{n+nv}{Parameters}\PYG{p}{,} \PYG{p}{[],} \PYG{n+nv}{History}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}! run\PYGZus{}fsm\PYGZus{}loop(+Module, +CurrentState, +Parameters, +Acc, \PYGZhy{}History) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} Main FSM execution loop. Repeatedly applies transitions until}
\PYG{c+c1}{\PYGZpc{} reaching an accept state.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} @param Module The FSM module}
\PYG{c+c1}{\PYGZpc{} @param CurrentState Current FSM state}
\PYG{c+c1}{\PYGZpc{} @param Parameters Strategy parameters}
\PYG{c+c1}{\PYGZpc{} @param Acc History accumulator}
\PYG{c+c1}{\PYGZpc{} @param History Final execution history}
\PYG{c+c1}{\PYGZpc{}}
\PYG{n+nf}{run\PYGZus{}fsm\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{Module}\PYG{p}{,} \PYG{n+nv}{CurrentState}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{n+nv}{Parameters}\PYG{p}{,} \PYG{n+nv}{Acc}\PYG{p}{,} \PYG{n+nv}{History}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} Check if we\PYGZsq{}re in an accept state}
    \PYG{n+nv}{Module}\PYG{l+s+sAtom}{:}\PYG{n+nf}{accept\PYGZus{}state}\PYG{p}{(}\PYG{n+nv}{CurrentState}\PYG{p}{),}
    \PYG{p}{!,}
    \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{fsm\PYGZus{}completion}\PYG{p}{),}
    \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n+nv}{Acc}\PYG{p}{,} \PYG{n+nv}{History}\PYG{p}{),}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}  [FSM Engine] Reached accept state\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[]).}

\PYG{n+nf}{run\PYGZus{}fsm\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{Module}\PYG{p}{,} \PYG{n+nv}{CurrentState}\PYG{p}{,} \PYG{n+nv}{Parameters}\PYG{p}{,} \PYG{n+nv}{Acc}\PYG{p}{,} \PYG{n+nv}{History}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} Apply a transition}
    \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{fsm\PYGZus{}transition}\PYG{p}{),}
    \PYG{n+nv}{Module}\PYG{l+s+sAtom}{:}\PYG{n+nf}{transition}\PYG{p}{(}\PYG{n+nv}{CurrentState}\PYG{p}{,} \PYG{n+nv}{NextState}\PYG{p}{,} \PYG{n+nv}{Interpretation}\PYG{p}{),}

    \PYG{c+c1}{\PYGZpc{} Record this step}
    \PYG{n+nv}{Step} \PYG{o}{=} \PYG{n+nf}{step}\PYG{p}{(}\PYG{n+nv}{CurrentState}\PYG{p}{,} \PYG{n+nv}{NextState}\PYG{p}{,} \PYG{n+nv}{Interpretation}\PYG{p}{),}

    \PYG{c+c1}{\PYGZpc{} Continue execution}
    \PYG{n+nf}{run\PYGZus{}fsm\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{Module}\PYG{p}{,} \PYG{n+nv}{NextState}\PYG{p}{,} \PYG{n+nv}{Parameters}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{Step}\PYG{p}{|}\PYG{n+nv}{Acc}\PYG{p}{],} \PYG{n+nv}{History}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}! extract\PYGZus{}result\PYGZus{}from\PYGZus{}history(+History, \PYGZhy{}Result) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} Extracts the final result from an FSM execution history.}
\PYG{c+c1}{\PYGZpc{} Looks for the final state and extracts the result value.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} @param History Execution history from run\PYGZus{}fsm\PYGZus{}with\PYGZus{}base/5}
\PYG{c+c1}{\PYGZpc{} @param Result The computed result}
\PYG{c+c1}{\PYGZpc{}}
\PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}history}\PYG{p}{(}\PYG{n+nv}{History}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} Get the last step}
    \PYG{n+nf}{last}\PYG{p}{(}\PYG{n+nv}{History}\PYG{p}{,} \PYG{n+nv}{LastStep}\PYG{p}{),}

    \PYG{c+c1}{\PYGZpc{} Extract result from final state}
    \PYG{p}{(} \PYG{n+nv}{LastStep} \PYG{o}{=} \PYG{n+nf}{step}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{n+nv}{PrevState}\PYG{p}{,} \PYG{n+nv}{FinalState}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{n+nv}{Interpretation}\PYG{p}{)} \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}
        \PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}state}\PYG{p}{(}\PYG{n+nv}{FinalState}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)}
    \PYG{p}{;}
        \PYG{c+c1}{\PYGZpc{} Fallback: try to extract from interpretation}
        \PYG{n+nv}{LastStep} \PYG{o}{=} \PYG{n+nf}{step}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{n+nv}{State}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{n+nv}{NextState}\PYG{p}{,} \PYG{n+nv}{Interpretation}\PYG{p}{),}
        \PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}interpretation}\PYG{p}{(}\PYG{n+nv}{Interpretation}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}! extract\PYGZus{}result\PYGZus{}from\PYGZus{}state(+State, \PYGZhy{}Result) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} Extracts the result value from a state structure.}
\PYG{c+c1}{\PYGZpc{} Handles common state representations:}
\PYG{c+c1}{\PYGZpc{} \PYGZhy{} state(Name, Result, ...)}
\PYG{c+c1}{\PYGZpc{} \PYGZhy{} state with explicit result field}
\PYG{c+c1}{\PYGZpc{}}
\PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}state}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{n+nv}{Name}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{n+nv}{Rest}\PYG{p}{),} \PYG{n+nv}{Result}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{p}{!.}
\PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}state}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{n+nv}{Name}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{),} \PYG{n+nv}{Result}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{p}{!.}
\PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}state}\PYG{p}{(}\PYG{n+nv}{State}\PYG{p}{,} \PYG{n+nv}{State}\PYG{p}{).}  \PYG{c+c1}{\PYGZpc{} Fallback: state IS the result}

\PYG{c+c1}{\PYGZpc{}! extract\PYGZus{}result\PYGZus{}from\PYGZus{}interpretation(+Interpretation, \PYGZhy{}Result) is semidet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} Attempts to extract result from interpretation string.}
\PYG{c+c1}{\PYGZpc{} This is a fallback when state structure doesn\PYGZsq{}t contain result directly.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}interpretation}\PYG{p}{(}\PYG{n+nv}{Interpretation}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} Look for \PYGZdq{}Result: N\PYGZdq{} pattern in interpretation}
    \PYG{n+nf}{atom}\PYG{p}{(}\PYG{n+nv}{Interpretation}\PYG{p}{),}
    \PYG{n+nf}{atomic\PYGZus{}list\PYGZus{}concat}\PYG{p}{(}\PYG{n+nv}{Parts}\PYG{p}{,} \PYG{l+s+sAtom}{\PYGZsq{}Result: \PYGZsq{}}\PYG{p}{,} \PYG{n+nv}{Interpretation}\PYG{p}{),}
    \PYG{n+nv}{Parts} \PYG{o}{=} \PYG{p}{[}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{ResultAtom}\PYG{p}{|}\PYG{k}{\PYGZus{}}\PYG{p}{],}
    \PYG{n+nf}{atom\PYGZus{}number}\PYG{p}{(}\PYG{n+nv}{ResultAtom}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{),}
    \PYG{p}{!.}
\PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}interpretation}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{l+s+sAtom}{unknown}\PYG{p}{).}

\end{MintedVerbatim}
