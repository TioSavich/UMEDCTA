<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>The Sound of Time: Dialog as Catastrophe (SVG)</title>
    <link rel="stylesheet" href="../style.css" /> <script src="zeeman.js"></script>
</head>
<body>

    <h2>The Sound of Time: Dialog as Catastrophe & Compression (SVG)</h2>

    <div class="visualization-container">

        <div class="zcm-container">
            <h3>Zeeman Catastrophe Machine (Dialog State)</h3>
            <div id="zcm-svg-elm-node">
                </div>
            <p class="caption">(Interactive ZCM rendered by Elm. Drag pointer to change dialog input.)</p>
        </div>

        <div class="speaker-container">
             <h3>Sound Metaphor (Meaning Expression)</h3>
             <svg id="speaker-svg" viewBox="0 0 550 350" preserveAspectRatio="xMidYMid meet">
                 </svg>
             <p class="caption">(Speaker wave animation driven by JavaScript based on ZCM changes.)</p>
        </div>

    </div> <div class="explanation">
        <h3>Metaphor Explanation: Dialogue as Embodied Vibration</h3>
        <p>
            This visualization explores human dialogue using metaphors from physics and philosophy. It connects the mechanics of a Zeeman Catastrophe Machine (ZCM) to the dynamics of understanding and the concept of Voice, drawing on ideas from Agamben, Hegel, and catastrophe theory [cite: 896, 971-973, 900-918]. The core idea is to represent the <strong>I/You</strong> relationship not just as a transcendental assumption, but as an embodied rhythm—a vibration between making distinctions and dissolving them, driven by the desire for recognition.
        </p>
        <ul>
            <li>
                <strong>ZCM State (Left Visualization):</strong> Represents the internal state of the dialogue—the emergent meaning or understanding.
                <ul>
                    <li><strong>Pointer/Crosshair (Your Input):</strong> Represents the speaker's articulation or communicative act. Moving this corresponds to changing what is said or how it's said.</li>
                    <li><strong>Wheel Angle (θ):</strong> The resulting stable "meaning state" or interpretation. This angle arises from the interplay of forces.</li>
                    <li><strong>Springs:</strong> Represent the forces in the dialogue. One spring connects to your input (speaker's effort), the other to a fixed point (listener's receptivity/resistance). <em>(Conceptually, the listener spring's stiffness could be adjustable to model dialogic tension or openness.)</em></li>
                </ul>
            </li>
            <li>
                <strong>Catastrophe & Determinate Negation:</strong> The ZCM exhibits cusp catastrophes—sudden jumps in the wheel's angle (θ) even with smooth input changes [cite: 897, 934-936]. This models moments of abrupt shifts in understanding or misunderstanding in dialogue. These shifts relate to <strong>determinate negation</strong>—the act of making distinctions (e.g., asserting "this" means excluding "not this") [cite: 97, 113, 125, 540-542, 913, 937-938]. A catastrophe occurs when the system crosses a threshold where one stable meaning state disappears.</li>
             <li>
                <strong>Sound Wave Metaphor (Right Visualization):</strong> Represents the physical manifestation of voice (sound/<em>phonē</em>) and the expression of meaning.
                <ul>
                    <li><strong>Speaker/Piston:</strong> Its movement is driven by the <em>change</em> in the ZCM's angle (dθ/dt).</li>
                    <li><strong>Compression/Decompression:</strong> A large, sudden change in meaning (a catastrophe) causes a strong push (<strong>Compression</strong>) or pull (<strong>Decompression</strong>) of the speaker piston, creating a pronounced wave [cite: 200-201, 654]. This visualizes the impact or "sound" of that meaning shift. Smooth changes in θ result in gentle waves.</li>
                    <li><strong>Air Particles:</strong> Represent the medium through which meaning propagates, visualizing the compression and decompression waves.</li>
                </ul>
            </li>
            <li>
                <strong>Voice vs. voice & Temporal Compression:</strong> The simulation distinguishes the physical sound wave (voice) from the internal state change (Voice/meaning). Meaning isn't just the sound; it emerges from the interaction. This also relates to <strong>temporal compression</strong>: forms and concepts (like "triangle" or "recognition") compress past experiences. Dialogue involves deploying these compressed forms (speaking) and decompressing them (listening, letting go of assumptions to understand). The listener's role involves this temporal decompression.
            </li>
             <li>
                <strong>Recognition Desire & I/You:</strong> The interaction aims to model the fundamental desire to be understood and recognized. The dynamic interplay between the speaker's input and the listener's response (mediated by the machine's state) is a metaphor for the I/You relationship striving for mutual understanding, sometimes smoothly, sometimes catastrophically.
            </li>
        </ul>
        <p>
            Interact by dragging the pointer in the ZCM area (left). Observe how its movement affects the wheel's angle (θ) and simultaneously drives the speaker piston and air waves on the right. Notice how sudden jumps in θ (catastrophes) create more dramatic sound waves.
        </p>
         <p><em>Note: The simulation uses physics-based calculations adapted from existing ZCM models. The Elm application handles the ZCM visualization and state, while separate JavaScript handles the speaker wave animation based on changes communicated (implicitly, in this setup) from the ZCM's state. The ability to explore the full ZCM behavior might still be limited by the internal coordinate system of the Elm application.</em></p>
    </div>

    <script type="text/javascript">

        // --- ZCM Calculation Logic (Parallel JS Simulation) ---
        const scale = 60;
        const Ox = 125;
        const Oy = 250;
        const la = 1.40407148348;

        let mX = Ox - scale;
        let mY = Oy;
        let u = 0, v = 0;
        let globalTheta = -1.011929266; // Renamed from theta
        let previousGlobalTheta = globalTheta; // Renamed from previousTheta

        // --- Speaker SVG & Wave Vars (Renamed to avoid conflicts) ---
        let js_speakerSvg; // Renamed from speakerSvg
        let js_pistonRect; // Renamed from pistonRect
        let js_airParticles = []; // Renamed from airParticles
        const numAirParticles = 500;
        const particleRadius = 1.5;
        const speakerBaseX = 50;
        const speakerWidth = 30;
        const speakerHeight = 100;
        const speakerY = 125;
        const chamberEndX = 500;
        const chamberWidth = chamberEndX - speakerBaseX;
        let speakerDisplacement = 0; // This is calculated displacement, name OK
        const maxSpeakerDisplacement = 40;
        const sensitivityScale = 10;
        const waveSpeed = 5;
        const fps = 60;
        const historySeconds = 1.0;
        const js_speakerHistory = new Array(Math.ceil(fps * historySeconds)).fill(0); // Renamed
        let js_historyIndex = 0; // Renamed
        const particleSpacing = chamberWidth / Math.sqrt(numAirParticles);

        // --- Elm App ---
        let elmApp;
        let zcmSvgContainer;


        // --- Core Calculation Functions (getTheta, getVt) ---
        function getTheta(theta0, u_calc, v_calc) {
            let currentTheta = theta0;
            const ACC_theta = 1e-4;
            const maxIter = 300;
            let dt_factor = 0.08;
            let Vt_old = 0;
            for (let j = 0; j < maxIter; j++) {
                Vt_old = getVt(currentTheta, u_calc, v_calc);
                if (isNaN(Vt_old)) { console.warn("Vt NaN"); return theta0; }
                if (Math.abs(Vt_old) < ACC_theta) break;
                currentTheta -= dt_factor * Vt_old;
                while (currentTheta >= Math.PI) currentTheta -= 2 * Math.PI;
                while (currentTheta < -Math.PI) currentTheta += 2 * Math.PI;
            }
            while (currentTheta >= Math.PI) currentTheta -= 2 * Math.PI;
            while (currentTheta < -Math.PI) currentTheta += 2 * Math.PI;
            return currentTheta;
        }
        function getVt(theta_calc, u_calc, v_calc) {
             var c = Math.cos(theta_calc); var s = Math.sin(theta_calc);
             var rf_sq = 17 / 4 - 2 * c; if (rf_sq < 0) rf_sq = 1e-9;
             var rf = Math.sqrt(rf_sq);
             var rg_sq = u_calc * (u_calc + c) + v_calc * (v_calc - s) + 1 / 4; if (rg_sq < 0) rg_sq = 1e-9;
             var rg = Math.sqrt(rg_sq);
             var ft = 2 * s; var gt = -u_calc * s - v_calc * c;
             var rfp = (rf > 1e-9) ? (1 - 1 / rf) : 0; var rgp = (rg > 1e-9) ? (1 - 1 / rg) : 0;
             if (isNaN(rfp) || isNaN(rgp) || isNaN(ft) || isNaN(gt)) { console.warn("getVt NaN"); return 0; }
             return rfp * ft + rgp * gt;
        }

        // --- SVG Speaker Initialization (Using Renamed Vars) ---
        function initSpeakerSvg() {
            // Assign to renamed global variable
            js_speakerSvg = document.getElementById('speaker-svg');
            if (!js_speakerSvg) { console.error("Speaker SVG not found"); return; }
            const svgNS = "http://www.w3.org/2000/svg";
            while (js_speakerSvg.firstChild) { js_speakerSvg.removeChild(js_speakerSvg.firstChild); }

            let wallTop = document.createElementNS(svgNS, 'line');
            wallTop.setAttribute('x1', speakerBaseX); wallTop.setAttribute('y1', speakerY);
            wallTop.setAttribute('x2', chamberEndX); wallTop.setAttribute('y2', speakerY);
            wallTop.setAttribute('stroke', '#666'); wallTop.setAttribute('stroke-width', '2');
            js_speakerSvg.appendChild(wallTop);
            let wallBottom = document.createElementNS(svgNS, 'line');
            wallBottom.setAttribute('x1', speakerBaseX); wallBottom.setAttribute('y1', speakerY + speakerHeight);
            wallBottom.setAttribute('x2', chamberEndX); wallBottom.setAttribute('y2', speakerY + speakerHeight);
            wallBottom.setAttribute('stroke', '#666'); wallBottom.setAttribute('stroke-width', '2');
            js_speakerSvg.appendChild(wallBottom);
            let wallEnd = document.createElementNS(svgNS, 'line');
            wallEnd.setAttribute('x1', chamberEndX); wallEnd.setAttribute('y1', speakerY);
            wallEnd.setAttribute('x2', chamberEndX); wallEnd.setAttribute('y2', speakerY + speakerHeight);
            wallEnd.setAttribute('stroke', '#666'); wallEnd.setAttribute('stroke-width', '2');
            js_speakerSvg.appendChild(wallEnd);

            // Assign to renamed global variable
            js_pistonRect = document.createElementNS(svgNS, 'rect');
            js_pistonRect.setAttribute('x', speakerBaseX - speakerWidth);
            js_pistonRect.setAttribute('y', speakerY);
            js_pistonRect.setAttribute('width', speakerWidth);
            js_pistonRect.setAttribute('height', speakerHeight);
            js_pistonRect.setAttribute('fill', '#888');
            js_pistonRect.setAttribute('stroke', '#333'); js_pistonRect.setAttribute('stroke-width', '1');
            js_speakerSvg.appendChild(js_pistonRect);

            // Use renamed global variable
            js_airParticles = [];
            const particleGroup = document.createElementNS(svgNS, 'g');
            js_speakerSvg.appendChild(particleGroup);
            const startX = speakerBaseX + particleRadius + 5; const endX = chamberEndX - particleRadius - 5;
            const startY = speakerY + particleRadius + 5; const endY = speakerY + speakerHeight - particleRadius - 5;
            const numX = Math.ceil(Math.sqrt(numAirParticles * (endX - startX) / (endY - startY)));
            const numY = Math.ceil(numAirParticles / numX);
            const stepX = (numX > 1) ? (endX - startX) / (numX -1) : 0; const stepY = (numY > 1) ? (endY - startY) / (numY -1) : 0;
            for (let i = 0; i < numX; i++) {
                for (let j = 0; j < numY; j++) {
                     if (js_airParticles.length >= numAirParticles) break;
                     let baseX = startX + i * stepX + (Math.random() - 0.5) * (stepX || 10) * 0.3;
                     let baseY = startY + j * stepY + (Math.random() - 0.5) * (stepY || 10) * 0.3;
                     let circle = document.createElementNS(svgNS, 'circle');
                     circle.setAttribute('cx', baseX.toFixed(1)); circle.setAttribute('cy', baseY.toFixed(1));
                     circle.setAttribute('r', particleRadius); circle.setAttribute('fill', '#369');
                     particleGroup.appendChild(circle);
                     js_airParticles.push({ element: circle, baseX: baseX, baseY: baseY });
                }
                 if (js_airParticles.length >= numAirParticles) break;
            }
        }

        // --- Animation Loop (Using Renamed Vars) ---
        let animationFrameId = null;
        function animate() {
            // 1. Calculate ZCM state (globalTheta)
            v = (mX - Ox) / scale; u = (mY - Oy) / scale + la;
            if (!isFinite(u) || !isFinite(v)) {
                 // Skip update if u/v invalid
            } else {
                 globalTheta = getTheta(globalTheta, u, v);
            }

            // 2. Calculate dTheta
            let dTheta = globalTheta - previousGlobalTheta;
            if (!isFinite(dTheta)) dTheta = 0;
            if (dTheta > Math.PI) dTheta -= 2 * Math.PI;
            if (dTheta < -Math.PI) dTheta += 2 * Math.PI;

            // 3. Calculate speaker displacement & update history
            speakerDisplacement = maxSpeakerDisplacement * Math.tanh(dTheta * sensitivityScale);
            if (!isFinite(speakerDisplacement)) speakerDisplacement = 0;
            // Use renamed history array and index
            js_speakerHistory[js_historyIndex] = speakerDisplacement;
            js_historyIndex = (js_historyIndex + 1) % js_speakerHistory.length;

            // 4. Update Speaker Piston SVG (use renamed rect var)
            if (js_pistonRect) {
                 js_pistonRect.setAttribute('x', (speakerBaseX - speakerWidth + speakerDisplacement).toFixed(1));
            }

            // 5. Update Air Particle SVGs (use renamed particle array and history)
            const currentHistoryIndex = js_historyIndex; // Use renamed index
            for(let i = 0; i < js_airParticles.length; i++) { // Use renamed particle array
                const p = js_airParticles[i];
                const distance = p.baseX - speakerBaseX;
                const timeDelay = distance / waveSpeed;
                let lookBackIndex = Math.round(currentHistoryIndex - 1 - timeDelay);
                lookBackIndex = (lookBackIndex % js_speakerHistory.length + js_speakerHistory.length) % js_speakerHistory.length; // Use renamed history
                const historicalDisplacement = js_speakerHistory[lookBackIndex] || 0; // Use renamed history
                const damping = Math.exp(-0.003 * distance);
                const currentX = p.baseX + historicalDisplacement * damping;
                const pistonFaceX = speakerBaseX + speakerDisplacement;
                const clampedX = Math.max(
                    pistonFaceX + particleRadius,
                    Math.min(chamberEndX - particleRadius, currentX)
                );
                 p.element.setAttribute('cx', clampedX.toFixed(1));
            }

            // 6. Store theta for next frame
            previousGlobalTheta = globalTheta; // Use renamed variable

            // 7. Request next frame
            animationFrameId = requestAnimationFrame(animate);
        }


        // --- Initialization ---
        function initialize() {
            console.log("Initializing visualization...");
             if (animationFrameId) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
             }
            zcmSvgContainer = document.getElementById('zcm-svg-elm-node');
            if (!zcmSvgContainer) {
                console.error("CRITICAL: Elm container node '#zcm-svg-elm-node' not found!");
                document.body.insertAdjacentHTML('afterbegin', "<p style='color: red; font-weight: bold;'>Error: HTML container for the ZCM visualization is missing.</p>");
                return;
            }
            if (typeof Elm === 'undefined') {
                 console.error("Elm object not found. Ensure zeeman.js is loaded correctly and before this script potentially.");
                 zcmSvgContainer.innerHTML = "<p style='color: red;'>Error: Could not load Elm application (Elm object not found). Please ensure zeeman.js loaded correctly.</p>";
                 return;
            }
            try {
                 console.log("Initializing Elm app...");
                 zcmSvgContainer.innerHTML = '';
                 elmApp = Elm.Main.init({ node: zcmSvgContainer });
                 console.log("Elm app initialized:", elmApp);
            } catch (e) {
                 console.error("Elm initialization failed:", e);
                 zcmSvgContainer.innerHTML = "<p style='color: red;'>Error loading ZCM visualization. Check console.</p>";
                 return;
            }
            initSpeakerSvg(); // Initialize speaker visuals
             zcmSvgContainer.addEventListener('mousemove', (e) => {
                const rect = zcmSvgContainer.getBoundingClientRect();
                 mX = e.clientX - rect.left;
                 mY = e.clientY - rect.top;
             });
             animate(); // Start speaker animation loop
             console.log("Initialization complete, animation started.");
        }

        // Defer initialization until the DOM is fully loaded
        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", initialize);
        } else {
            initialize();
        }

    </script>

</body>
</html>